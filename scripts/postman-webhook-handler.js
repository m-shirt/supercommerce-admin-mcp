#!/usr/bin/env node

/**
 * Postman Webhook Handler
 * This script handles webhooks from Postman when collections are updated
 * and triggers the tool generation process.
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Download updated collection from Postman
 */
async function downloadCollection(collectionId, apiKey) {
  const url = `https://api.getpostman.com/collections/${collectionId}`;

  try {
    const response = await fetch(url, {
      headers: {
        'X-API-Key': apiKey
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to download collection: ${response.statusText}`);
    }

    const data = await response.json();
    return data.collection;
  } catch (error) {
    console.error('Error downloading collection:', error);
    throw error;
  }
}

/**
 * Save collection to file
 */
function saveCollection(collection, filename = 'Backend APIs.postman_collection.json') {
  const collectionPath = path.join(__dirname, '../postman/collections', filename);

  // Ensure directory exists
  const dir = path.dirname(collectionPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Save collection
  fs.writeFileSync(collectionPath, JSON.stringify(collection, null, 2));
  console.log(`âœ… Collection saved to: ${collectionPath}`);

  return collectionPath;
}

/**
 * Generate tools from the updated collection
 */
async function generateTools() {
  const scriptPath = path.join(__dirname, 'generate-tools-from-postman.js');

  try {
    const { stdout, stderr } = await execAsync(`node ${scriptPath}`);
    console.log('Tool generation output:', stdout);
    if (stderr) console.error('Tool generation errors:', stderr);

    // Parse output to check if new tools were generated
    const newToolsMatch = stdout.match(/Generated (\d+) new MCP tools/);
    const newToolsCount = newToolsMatch ? parseInt(newToolsMatch[1]) : 0;

    return {
      success: true,
      newToolsCount,
      output: stdout
    };
  } catch (error) {
    console.error('Error generating tools:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Commit and push changes
 */
async function commitAndPush(newToolsCount) {
  try {
    // Stage changes
    await execAsync('git add tools/ postman/');

    // Commit
    const commitMessage = `feat: auto-generate ${newToolsCount} new MCP tools from Postman

This commit was automatically generated by the Postman webhook handler.
New tools have been created based on updates to the Postman collection.

ðŸ¤– Generated by Postman Webhook`;

    await execAsync(`git commit -m "${commitMessage}"`);

    // Push to remote
    await execAsync('git push origin master');

    console.log('âœ… Changes committed and pushed to repository');
    return true;
  } catch (error) {
    console.error('Error committing changes:', error);
    return false;
  }
}

/**
 * Handle Postman webhook
 */
export async function handleWebhook(webhookData) {
  console.log('ðŸ”„ Processing Postman webhook...');

  try {
    // Extract collection ID from webhook data
    const collectionId = webhookData.collection_id || webhookData.model_id;
    const apiKey = process.env.POSTMAN_API_KEY;

    if (!collectionId) {
      throw new Error('Collection ID not found in webhook data');
    }

    if (!apiKey) {
      throw new Error('POSTMAN_API_KEY environment variable not set');
    }

    // Download updated collection
    console.log('ðŸ“¥ Downloading updated collection...');
    const collection = await downloadCollection(collectionId, apiKey);

    // Save collection to file
    const collectionPath = saveCollection(collection);

    // Generate tools
    console.log('ðŸ› ï¸  Generating MCP tools...');
    const result = await generateTools();

    if (!result.success) {
      throw new Error(`Tool generation failed: ${result.error}`);
    }

    // If new tools were generated, commit and push
    if (result.newToolsCount > 0) {
      console.log(`ðŸ“ ${result.newToolsCount} new tools generated`);

      // Commit and push changes
      const pushed = await commitAndPush(result.newToolsCount);

      if (pushed) {
        console.log('âœ… Webhook processing complete!');
        return {
          success: true,
          message: `Successfully generated ${result.newToolsCount} new tools and pushed to repository`,
          newToolsCount: result.newToolsCount
        };
      } else {
        return {
          success: true,
          message: `Generated ${result.newToolsCount} new tools but failed to push to repository`,
          newToolsCount: result.newToolsCount,
          warning: 'Manual push required'
        };
      }
    } else {
      console.log('âœ… No new tools needed - collection is up to date');
      return {
        success: true,
        message: 'Collection is up to date, no new tools generated',
        newToolsCount: 0
      };
    }
  } catch (error) {
    console.error('âŒ Webhook processing failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Express webhook endpoint handler
 */
export function createWebhookEndpoint(app) {
  app.post('/webhook/postman', async (req, res) => {
    console.log('Received Postman webhook:', req.body);

    // Verify webhook signature (if Postman provides one)
    // TODO: Add signature verification when available

    // Process webhook asynchronously
    handleWebhook(req.body)
      .then(result => {
        console.log('Webhook processing result:', result);
      })
      .catch(error => {
        console.error('Webhook processing error:', error);
      });

    // Respond immediately to Postman
    res.json({
      received: true,
      message: 'Webhook received and processing started'
    });
  });
}

// If run directly, process a test webhook
if (import.meta.url === `file://${__filename}`) {
  const testWebhook = {
    collection_id: process.argv[2] || '48096048-702f6202-ffc4-404e-9e71-5c5458b5cdc7',
    event: 'collection.update',
    timestamp: new Date().toISOString()
  };

  console.log('Testing webhook handler with:', testWebhook);
  handleWebhook(testWebhook).then(console.log).catch(console.error);
}